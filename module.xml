<?xml version="1.0" ?>
<!--@POSTPROC: ./postproc.sh-->
<module suppressWarnings="true">

<User f="nodata">
  <User f="noscroll">
    <User    t="dropdown" f="user"/>
    <Log_in t="button" ll="Start"/>
  </User>
</User>

<Start f="nodata">
  <Main>
    <Take_Feature t="button" l="Burial_Mound"/>
    <autonum/>
    <GPS_Diagnostics t="gpsdiag"/>
  </Main>
  <search>
    Records
  </search>
  <Table f="noscroll">
    <Table>
      <!--This is replaced with a table view using @POSTPROC-->
    </Table>
  </Table>
  <Map f="noscroll">
    <Map t="map"/>
    <Create_Shape t="button" l="Shape"/>
  </Map>
</Start>

<Burial_Mound>
  <General>
    <Object_ID f="id notnull autonum"/>
    <Date f="readonly"/>
    <author/>
    <Type f="notnull">
      <opts>
        <opt>Burial Mound</opt>
        <opt>Extinct Burial Mound</opt>
        <opt>Uncertain Feature</opt>
        <opt>Surface concentration</opt>
        <opt>Natural Feature</opt>
        <opt>Unknown</opt>
        <opt>Other</opt>
      </opts>
    </Type>
    <Source>
      <opts>
        <opt>Legacy verification</opt>
        <opt>Survey</opt>
        <opt>Local informant</opt>
        <opt>Serendipity</opt>
        <opt>Other</opt>
      </opts>
    </Source>
    <Description_of_Mound_or_Locale>
      <desc>
        Describe the location in relation to local topography and relief (optional)
      </desc>
    </Description_of_Mound_or_Locale>
    <Landuse_around_Mound>
      <desc>Landuse around the mound. Choose the majority landuse.</desc>
      <opts>
        <opt>
          Annual agriculture
        </opt>
        <opt>
          Perennial agriculture (e.g orchard or vineyard)
        </opt>
        <opt>
          Pasture (grassland)
        </opt>
        <opt>
          Scrub
        </opt>
        <opt>
          Forest
        </opt>
        <opt>
          Urban (in a settlement or surrounded by infrastructure)
        </opt>
        <opt>
          Other (explain in notes)
        </opt>
      </opts>
    </Landuse_around_Mound>
    <Landuse_on_top_of_Mound>
      <desc>Landuse on top of mound. Choose majority.</desc>
      <opts>
        <opt>
          Annual agriculture
        </opt>
        <opt>
          Perennial agriculture (e.g orchard or vineyard)
        </opt>
        <opt>
          Pasture (grassland)
        </opt>
        <opt>
          Scrub
        </opt>
        <opt>
          Forest
        </opt>
        <opt>
          Urban (in a settlement or surrounded by infrastructure)
        </opt>
        <opt>
          Other (explain in notes)
        </opt>
      </opts>
    </Landuse_on_top_of_Mound>
    <Prominence>
      <opts>
        <opt>Valley Bottom or Plain</opt>
        <opt>
          Upper slope
          <desc>Upper and lower slope - mentally divide the slope in half and poinpoint your position within upper or lower part.</desc>
        </opt>
        <opt>Lower slope</opt>
        <opt>Hilltop</opt>
      </opts>
    </Prominence>
    <gps/>
    <Elevation b="decimal">
      Elevation (MASL)
      <desc>
        Only enter value if present in the map. List source in Annotation
      </desc>
    </Elevation>
    <Facing_Direction_For_Photo>
      <opts>
        <opt>No Observation</opt>
        <opt>North</opt>
        <opt>Northeast</opt>
        <opt>East</opt>
        <opt>Southeast</opt>
        <opt>South</opt>
        <opt>Southwest</opt>
        <opt>West</opt>
        <opt>Northwest</opt>
        <opt>Other</opt>
      </opts>
    </Facing_Direction_For_Photo>
    <Mound_Overview_Photo t="camera">
      <desc>Take 1 general overview shot that includes the complete feature profile, and a scale. Include direction in the Annotation (from which direction was the image taken)</desc>
    </Mound_Overview_Photo>
  </General>
  <Dimensions>
    <cols>
      <col>
        <Height_Max b="decimal" f="notnull">
          Height Max (m)
        </Height_Max>
        <Diameter_Max   b="decimal" f="notnull">
          Diameter Max (m)
          <desc>
            The longest axis in the diameter
          </desc>
        </Diameter_Max>
      </col>
      <col>
        <Height_Min b="decimal">
          Height Min (m)
        </Height_Min>
        <Diameter_Min   b="decimal">
          Diameter Min (m)
          <desc>
            The shorter axis in diameter, if mound ellipsoid
          </desc>
        </Diameter_Min>
      </col>
    </cols>
    <Other_Dimension/>
    <Shape_Notes/>
  </Dimensions>
  <Material>
    <Associated_Feature_or_Material t="checkbox">
      <opts>
        <opt>
          Stone wall (krepis)
          <desc>
            Stone wall (krepis) is found either at the foot of the mound, or inside it (upon excavation).
          </desc>
        </opt>
        <opt>
          Enclosure
          <desc>
            Enclosure is a fence or a circle of variable material either around or some distance outside of the mound.
          </desc>
        </opt>
        <opt>
          Standing features in vicinity
          <desc>
            Standing features in the vicinity comprise other standing stone or architectural features associated with the mound.
          </desc>
        </opt>
        <opt>
          Artefact scatter
          <desc>
            Artefact scatter indicates a discreet and bounded concentration of manmade objects on the surface.
          </desc>
        </opt>
        <opt>
          Loose artefacts
          <desc>
            Loose artefacts indicates one or two artefacts dispersed on or around mound.
          </desc>
        </opt>
        <opt>
          Bones
          <desc>
            Bones denote bioarchaeological remains, human or animal.
          </desc>
        </opt>
        <opt>
          Other
          <desc>
            Other - please use the annotation to describe.
          </desc>
        </opt>
      </opts>
    </Associated_Feature_or_Material>
    <Surface_Material_Description>
      <desc>
        Please comment on the density, dimensions, boundedness, and other characteristics of the associated surface materials.
      </desc>
    </Surface_Material_Description>
    <Sample_Collected t="radio">
      Sample Collected?
      <opts>
        <opt>Yes</opt>
        <opt>No</opt>
      </opts>
    </Sample_Collected>
    <Chronology_Estimate/>
    <Associated_Feature_or_Material_Photo t="camera"/>
  </Material>
  <CRM>
    <Condition>
      <opts>
        <opt>
          0 - No observation
        </opt>
        <opt>
          1 - pristine
          <desc>
            1 - only superficial or minor damage, 10% of mound volume missing.
          </desc>
        </opt>
        <opt>
          2 - minor damage
          <desc>
            2- minor damage, 10-25% of mound volume missing, archaeological potential not seriously compromised.
          </desc>
        </opt>
        <opt>
          3 - damaged
          <desc>
            3 - up to 50% of mound volume missing, archaeological potential compromised.
          </desc>
        </opt>
        <opt>
          4 - seriously damaged
          <desc>
            4 - either 50% of mound missing or archaeological potential seriously compromised.
          </desc>
        </opt>
        <opt>
          5 - extinct or near extinct
          <desc>
            5 - nearly nothing remains of the mound, archaeological potential nil or nearly nil.
          </desc>
        </opt>
        <opt>
          NA
        </opt>
      </opts>
    </Condition>
    <Principal_Source_of_Impact>
      <opts>
        <opt>Not available</opt>
        <opt>Agriculture</opt>
        <opt>Looting</opt>
        <opt>Infrastructure</opt>
        <opt>Urban development</opt>
        <opt>Animal activity</opt>
        <opt>Topographic or post-depositional</opt>
        <opt> Other (specify in Annotation)</opt>
      </opts>
    </Principal_Source_of_Impact>
    <Other_Sources_of_Impact/>
    <Most_recent_damage_what>
      Most recent damage (what)
      <opts>
        <opt>Not available</opt>
        <opt>Agriculture</opt>
        <opt>Looting</opt>
        <opt>Infrastructure</opt>
        <opt>Urban development</opt>
        <opt>Animal activity</opt>
        <opt>Topographic or post-depositional</opt>
        <opt> Other (specify in Annotation)</opt>
      </opts>
    </Most_recent_damage_what>
    <Most_recent_damage_within>
      Most recent damage (within)
      <opts>
        <opt>Last week</opt>
        <opt>Last month</opt>
        <opt>Last year</opt>
        <opt>Unknown</opt>
        <opt>Other</opt>
      </opts>
    </Most_recent_damage_within>
    <RT_Description/>
    <Comments_and_Recommendations/>
    <CRM_Photo t="camera"/>
  </CRM>
</Burial_Mound>

<Shape>
  <Shape_Note>
    <Label f="id"/>
    <Note/>
  </Shape_Note>
</Shape>

<logic><![CDATA[
/************************************ MAP *************************************/
DATA_ENTRY_LAYER    = "Data Entry Layer";
DATA_ENTRY_LAYER_ID = 0;

void initMap() {
  String refMap = "Start/Map/Map";

  setMapZoom(refMap, 15.0f);

  // Shape
  isEntity = true;
  queryName = "Shape";
  querySQL = "SELECT uuid, aenttimestamp FROM latestNonDeletedArchEnt join aenttype using (aenttypeid) where aenttypename = 'Shape'";
  ps = createPointStyle(10, Color.YELLOW, 0.2f, 0.5f);
  ls = createLineStyle(10, Color.YELLOW, 0.05f, 0.3f, null);
  pos = createPolygonStyle(10, Color.parseColor("#440000FF"), createLineStyle(10, Color.parseColor("#AA000000"), 0.01f, 0.3f, null));
  ts = createTextStyle(10, Color.YELLOW, 30, Typeface.SANS_SERIF);
  showDatabaseLayer(refMap, "Shape Layer", isEntity, queryName, querySQL, ps, ls, pos, ts);

  // Data entry layer
  DATA_ENTRY_LAYER_ID = createCanvasLayer(refMap, DATA_ENTRY_LAYER);
  setSelectedLayer(refMap, DATA_ENTRY_LAYER);
}

// Copy/pasted from autogenerator's definition of saveTabGroup
void saveShape() {
  String  tabgroup            = "Shape";
  Boolean enableAutosave      = true;
  String  id                  = getUuid(tabgroup);
  String  mapRef              = "Start/Map/Map";
  List    geometry            = getGeometryList(mapRef, DATA_ENTRY_LAYER_ID);
  List    attributes          = null;
  String  parentTabgroup_     = parentTabgroup;
  String  parentTabgroupUuid_ = getUuid(parentTabgroup_);
  Boolean userWasSet          = !username.equals("");

  String callback = "";
  callback += "; clearGeometry()";
  callback += "; onSave" + getArchEntTypePascalCased(tabgroup) + "__()";

  parentTabgroup = null;

  SaveCallback saveCallback  = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      // Make a child-parent relationship if need be.
      if (
          newRecord &&
          !isNull(parentTabgroup_) &&
          !isNull(parentTabgroupUuid_)
      ) {
        String rel = "";
        rel += parentTabgroup_.replaceAll("_", " ");
        rel += " - ";
        rel += tabgroup.replaceAll("_", " ");
        saveEntitiesToHierRel(
          rel,
          parentTabgroupUuid_,
          uuid,
          "Parent Of",
          "Child Of",
          callback
        );
      } else {
        execute(callback);
      }

      // This fixes an interesting bug. Without this, if a user was not set
      // (by calling `setUser`) at the time `saveShape` was first called, but
      // set by the time `onSave` was called, the tab group is saved correctly
      // the first time only.
      //
      // Adding this allows subsequent saves to succeed. Presumably it plays
      // some role in helping FAIMS associate the correct user with a record.
      if (!userWasSet) {
        saveShape();
      }

    }
    onError(message) {
      showToast(message);
    }
  };

  saveTabGroup(tabgroup, id, geometry, attributes, saveCallback, enableAutosave);
}

void clearGeometry() {
  String  mapRef   = "Start/Map/Map";
  List    geometry = getGeometryList(mapRef, DATA_ENTRY_LAYER_ID);

  if (geometry == null)     return;
  if (geometry.size() == 0) return;

  for (geom : geometry) {
    print("Geometry cleared:" + geom.userData.geomId);
    clearGeometry(mapRef, geom.userData.geomId);
  }
}

boolean checkForGeometry() {
  String mapRef = "Start/Map/Map";

  List geometry = getGeometryList(mapRef, DATA_ENTRY_LAYER_ID);
  if (geometry == null || geometry.size() == 0) {
    String head = "Cannot Create Shape";
    String body = "At least one shape must be present on the data entry layer.";
    showWarning(head, body);

    return false;
  } else {
    return true;
  }
}

void centreMe() {
  String mapRef = "Start/Map/Map";

  if(!isExternalGPSOn() && !isInternalGPSOn()) {
    showToast("{GPS_Not_Initialised}");
  } else {
    centerOnCurrentPosition(mapRef);
  }
}

void refreshMap() {
  String mapRef = "Start/Map/Map";
  refreshMap(mapRef);
}

// Overrides autogenerated definition
void onClickStartMapCreateShape () {
  if (checkForGeometry()) {
    parentTabgroup__ = "Start";
    newShape();
  }
}

// Overrides autogenerated definition
void onShowShape () {
  saveShape();
}

initMap();
//addOnEvent("Start/Map/Centre_Me", "click", "centreMe()");
addOnEvent("Start/Map",           "show",  "refreshMap()");

/****************************** DATE POPULATION *******************************/
  void setDayMonth() {
    ref     = "Burial_Mound/General/Date";

    fmt     = "dd MMM";
    date    = new Date();
    dateFmt = new java.text.SimpleDateFormat(fmt);
    dateStr = dateFmt.format(date);

    setFieldValue(ref, dateStr);
  }

  addOnEvent("Burial_Mound", "create", "setDayMonth()");

/********************************* TABLE VIEW *********************************/
  query  = "select uuid, 'identifier' as attributename, response, -1 as aentcountorder ";
  query += " from latestNonDeletedArchEntFormattedIdentifiers ";
  query += "where aenttypename='Burial Mound'";
  query += " union ";
  query += "select uuid, attributename, group_concat(format(formatstring, vocabname, measure, freetext, certainty), appendcharacterstring) as response, aentcountorder ";
  query += "  from ( ";
  query += "    select uuid, attributename, aenttypename, formatstring, vocabname, measure, freetext, certainty, appendcharacterstring, aentcountorder, vocabcountorder, attributeid ";
  query += "    from latestNonDeletedArchent ";
  query += "      JOIN aenttype using (aenttypeid) ";
  query += "      join idealaent using (aenttypeid) ";
  query += "      join attributekey using (attributeid) ";
  query += "      join latestNonDeletedAentValue using (uuid, attributeid) ";
  query += "      left outer join vocabulary using (attributeid, vocabid) ";
  query += "    order by uuid, aentcountorder, vocabcountorder ";
  query += "  ) ";
  query += "  where aenttypename='Burial Mound' ";
  query += "  and attributename in ('Object ID', 'Type', 'Date', 'Surrounding Landuse', 'Surface Landuse', 'Height Max', 'Length Max') ";
  query += "  group by uuid, attributeid ";
  query += "  having response is not null ";
  query += "  order by uuid, aentcountorder; ";

  tableRef       = "Start/Table/Table";
  headers        = new ArrayList();
  actionName     = "Load";
  actionIdx      = 0;
  actionCallback = "loadEntityFromTable()";

  headers.add("");
  headers.add("Object ID");
  headers.add("Type");
  headers.add("Date");
  headers.add("Surrounding Landuse");
  headers.add("Surface Landuse");
  headers.add("Height Max");
  headers.add("Length Max");

  populateTable() {
    populateTablePivot(tableRef, query, headers, actionName, actionIdx, actionCallback);
  }

  loadEntityFromTable() {
    uuid = getTableValue();
    loadEntityFrom(uuid); // Auto-gen'd function
  }

  addOnEvent(tableRef, "show", "populateTable()");

  /****************************** GIS POINT STYLES ******************************/
  final String MAP_REF = "Start/Map/Map";
  /* Displays the geometry of each entity whose menu, by the name of `attribName`,
   * has `vocabName` saved in it. The geometry is displayed in whatever colour is
   * given by `geoColor`.
   *
   * The geometry is displayed in a layer called `layerName`. This is a
   * human-readable name that the user can use to toggle the visibility of the
   * geometry in the UI.
   */
  void showDatabaseLayerByVocabName(
      String attribName,
      String vocabName,
      int    geoColor, /* Example argument: Color.BLACK */
      String layerName
  ) {
    int transBlk = Color.parseColor("#AA000000");
    GeometryStyle sln_ = createLineStyle(10, transBlk, 0.01f, 0.3f, null);
    // Define arguments to `showDatabaseLayer`
    String q;
    q  = "SELECT uuid, aenttimestamp";
    q += "  FROM latestNonDeletedArchEnt";
    q += "  JOIN latestnondeletedaentvalue USING (uuid)";
    q += "  JOIN attributekey              USING (attributeid)";
    q += "  JOIN vocabulary                USING (vocabid)";
    q += " WHERE {vocabName}  IN ('', vocabname)";
    q += "   AND {attribName} IN ('', attributename)";
    q  = dbReplaceFirst(q, "{vocabName}",  vocabName);
    q  = dbReplaceFirst(q, "{attribName}", attribName);
    boolean isEntity = true;
    GeometryStyle spt = createPointStyle(10, geoColor, 0.2f, 0.5f);
    GeometryStyle sln = createLineStyle(10, geoColor, 0.05f, 0.3f, null);
    GeometryStyle spg = createPolygonStyle(10, geoColor, sln_);
    GeometryTextStyle stx = createTextStyle(
        10,
        Color.BLACK,
        40,
        Typeface.SANS_SERIF
    );
    showDatabaseLayer(
        MAP_REF,
        layerName,
        isEntity,
        layerName,
        q,
        spt,
        sln,
        spg,
        stx
    );
  }
  void showDatabaseLayerByVocabName(
      String vocabName,
      int    geoColor,
      String layerName
  ) {
    showDatabaseLayerByVocabName("", vocabName, geoColor, layerName);
  }
  void showDatabaseLayerByVocabName(String vocabName, int geoColor) {
    String layerName = guessArch16nValFromKey(vocabName);
    showDatabaseLayerByVocabName(vocabName, geoColor, layerName);
  }
  void initMap() {
    // showBaseMap(MAP_REF, "Base Map", "files/data/R1980_YambolElhovoExt.tif");
    //showDatabaseLayerByVocabName("{1___pristine}",   Color.GREEN;
    showDatabaseLayerByVocabName("{2___minor_damage}", Color.BLUE);
    showDatabaseLayerByVocabName("{3___damaged}",  Color.YELLOW);
    //showDatabaseLayerByVocabName("{4___seriously_damaged}",   Color.ORANGE);
    //showDatabaseLayerByVocabName("{5___extinct_or_near_extinct}", Color.parseColor(#FF0000));
/*






    */
    showDatabaseLayerByVocabName("{NA}",  Color.BLACK);
    setMapZoom(MAP_REF, 13.0f);
  }
  initMap();

  /********************************* CUSTOM SEARCH ******************************/
  addOnEvent("Start/Search", "show", "populateSelectAuthor()");
  addOnEvent("Start/Search/Select_Author", "click", "search()");
  void populateSelectAuthor(){
  String refSearchUsers = "Start/Search/Select_Author";
  String getNonDeletedUsersQuery = "SELECT userid, fname || ' ' || lname "+
                                   "  FROM user "+
                                   " WHERE userdeleted is null "+
                                   " UNION " +
                                   "SELECT -1, '{All}'";

  fetchAll(getNonDeletedUsersQuery, new FetchCallback() {
    onFetch(result) {
      populateDropDown(refSearchUsers, result, false);
      search();
    }
  });
  }

  // Overrides auto-generated definition
  void search(){
  String refEntityList    = "Start/Search/Entity_List";
  String refSearchTerm    = "Start/Search/Search_Term";
  String refEntityTypes   = "Start/Search/Entity_Types";
  String refSelectAuthor  = "Start/Search/Select_Author";
  String type = getFieldValue(refEntityTypes);
  String term = getFieldValue(refSearchTerm);

  String user = getFieldValue(refSelectAuthor);
  String searchQuery = "SELECT uuid, response "+
                       "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
                       " WHERE uuid in (SELECT uuid "+
                       "                  FROM latestNonDeletedArchEntIdentifiers "+
                       "                 WHERE measure LIKE {term}||'%'  "+
                       "                   AND ( aenttypename = {type} OR '' = {type} ) "+
                       " AND ( userid = {user} OR -1 = {user}) " +
                       "                )  "+
                       " ORDER BY response "+
                       " LIMIT ? "+
                       "OFFSET ? ";
  searchQuery = dbReplaceFirst(searchQuery, "{term}", term);
  searchQuery = dbReplaceFirst(searchQuery, "{type}", type);
  searchQuery = dbReplaceFirst(searchQuery, "{type}", type);
  searchQuery = replaceFirst(searchQuery, "{user}", user);
  populateCursorList(refEntityList, searchQuery, 25);
  refreshTabgroupCSS("Start");

  Log.d("Module", "Search query: " + searchQuery);
  }
]]></logic>

</module>
